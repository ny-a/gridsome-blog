<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>Gridsome - Gridsome</title><meta name="gridsome:hash" content="649f8dfc2ee2548c04060933dbad2a7c513c85fa"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" name="generator" content="Gridsome v0.7.14"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><link data-vue-tag="ssr" rel="icon" href="data:,"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="16x16" href="/gridsome-blog/assets/static/favicon.ce0531f.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="32x32" href="/gridsome-blog/assets/static/favicon.ac8d93a.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="96x96" href="/gridsome-blog/assets/static/favicon.b9532cc.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="76x76" href="/gridsome-blog/assets/static/favicon.f22e9f3.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="152x152" href="/gridsome-blog/assets/static/favicon.62d22cb.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="120x120" href="/gridsome-blog/assets/static/favicon.1539b60.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="167x167" href="/gridsome-blog/assets/static/favicon.dc0cdc5.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="180x180" href="/gridsome-blog/assets/static/favicon.7b22250.9bb7ffafafc09ac851d81afb65b8ef59.png"><link rel="preload" href="/gridsome-blog/assets/css/0.styles.dd5de3ed.css" as="style"><link rel="preload" href="/gridsome-blog/assets/js/app.122eb624.js" as="script"><link rel="preload" href="/gridsome-blog/assets/js/page--src--templates--post-vue.c275e0ae.js" as="script"><link rel="prefetch" href="/gridsome-blog/assets/js/page--node-modules--gridsome--app--pages--404-vue.b08f0808.js"><link rel="prefetch" href="/gridsome-blog/assets/js/page--src--pages--index-vue.df9f8b29.js"><link rel="stylesheet" href="/gridsome-blog/assets/css/0.styles.dd5de3ed.css"><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript>
  </head>
  <body >
    <div data-server-rendered="true" id="app" class="layout"><header class="header"><strong><a href="/gridsome-blog/" class="active">Gridsome</a></strong><nav class="nav"><a href="/gridsome-blog/" class="nav__link active">Home</a></nav></header><div class="post-title"><h1>Xorgの仮想ディスプレイについて調べました</h1><p class="post-date"> 26 February 2020 | 1 min read</p></div><div class="post-content"><p><p>Linux デスクトップで、他のデバイスを VNC などを使って仮想的にワイアレスディスプレイとして使うために、
仮想ディスプレイを追加する方法を調べました。</p>
<h2 id="余っているディスプレイ出力を使う"><a href="#%E4%BD%99%E3%81%A3%E3%81%A6%E3%81%84%E3%82%8B%E3%83%87%E3%82%A3%E3%82%B9%E3%83%97%E3%83%AC%E3%82%A4%E5%87%BA%E5%8A%9B%E3%82%92%E4%BD%BF%E3%81%86" aria-hidden="true"><span class="icon icon-link"></span></a>余っているディスプレイ出力を使う</h2>
<p><a href="https://bbs.archlinux.org/viewtopic.php?id=180904" target="_blank" rel="nofollow noopener noreferrer">[SOLVED] Creating a Virtual Display/monitor - Arch Forum</a>
を見ると、余っている(ディスプレイを接続していない)ディスプレイ出力を使用して仮想ディスプレイを作成することができるようです。
ディスプレイを接続して表示している状態で切断した状態と同じだと思います。</p>
<p>ただ、前回これを使って VNC で接続した場合、リフレッシュレートがかなり下がってしまっていた記憶があるため、
他の方法を探してみました。</p>
<h2 id="virtual1を作成する"><a href="#virtual1%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B" aria-hidden="true"><span class="icon icon-link"></span></a>VIRTUAL1を作成する</h2>
<p><a href="https://unix.stackexchange.com/questions/378373/add-virtual-output-to-xorg" target="_blank" rel="nofollow noopener noreferrer">Add VIRTUAL output to Xorg - Stack Exchange</a>
を見てみると、 intel ドライバを使って VirtualHeads を作成することができるようです。</p>
<pre class="language-shell"><code class="language-shell"><span class="token function">sudo</span> pacman -S xf86-video-intel
<span class="token function">cat</span> <span class="token operator">&lt;&lt;</span>EOH <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /etc/X11/xorg.conf.d/20-intel-virtual-heads.conf
Section <span class="token string">"Device"</span>
    Identifier <span class="token string">"intelgpu0"</span>
    Driver <span class="token string">"intel"</span>
    Option <span class="token string">"VirtualHeads"</span> <span class="token string">"2"</span>
EndSection
EOH</code></pre>
<p>Xorg を再起動すると、output として VIRTUAL1 が追加されています。</p>
<p>ただ、
<a href="https://wiki.archlinux.jp/index.php/Intel_Graphics#.E3.82.A4.E3.83.B3.E3.82.B9.E3.83.88.E3.83.BC.E3.83.AB" target="_blank" rel="nofollow noopener noreferrer">Intel Graphics - Arch Wiki</a>
に書かれていますが、 <code>xf86-video-intel</code> は非推奨扱いになっていて、標準の <code>modesetting</code> ドライバが推奨されているようです。</p>
<p>とはいえ、
<a href="https://gitlab.freedesktop.org/xorg/xserver/issues/179" target="_blank" rel="nofollow noopener noreferrer">xorg/xserver Issue#179</a>
に issue が上がっていますが、 <code>modesetting</code> ドライバに VirtualHeads 機能は追加されていないようです。</p>
<p>modesetting ドライバで仮想ディスプレイを作成する方法も調べてみましたが、うまく情報をみつけることができませんでした。
本当は Xmonad のワークスペースをマシン間で任意に対応させたいのですが……それはかなり難しそうですね。</p>
</p></div><div class="footer"><p>
      Built with
      <a href="//gridsome.org" class="link">Gridsome</a></p></div></div>
    <script>window.__INITIAL_STATE__={"data":{"post":{"id":"91d0a5821ffa07a65a16dccbea9f8a48","title":"Xorgの仮想ディスプレイについて調べました","content":"\u003Cp\u003ELinux デスクトップで、他のデバイスを VNC などを使って仮想的にワイアレスディスプレイとして使うために、\n仮想ディスプレイを追加する方法を調べました。\u003C\u002Fp\u003E\n\u003Ch2 id=\"余っているディスプレイ出力を使う\"\u003E\u003Ca href=\"#%E4%BD%99%E3%81%A3%E3%81%A6%E3%81%84%E3%82%8B%E3%83%87%E3%82%A3%E3%82%B9%E3%83%97%E3%83%AC%E3%82%A4%E5%87%BA%E5%8A%9B%E3%82%92%E4%BD%BF%E3%81%86\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E余っているディスプレイ出力を使う\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fbbs.archlinux.org\u002Fviewtopic.php?id=180904\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003E[SOLVED] Creating a Virtual Display\u002Fmonitor - Arch Forum\u003C\u002Fa\u003E\nを見ると、余っている(ディスプレイを接続していない)ディスプレイ出力を使用して仮想ディスプレイを作成することができるようです。\nディスプレイを接続して表示している状態で切断した状態と同じだと思います。\u003C\u002Fp\u003E\n\u003Cp\u003Eただ、前回これを使って VNC で接続した場合、リフレッシュレートがかなり下がってしまっていた記憶があるため、\n他の方法を探してみました。\u003C\u002Fp\u003E\n\u003Ch2 id=\"virtual1を作成する\"\u003E\u003Ca href=\"#virtual1%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EVIRTUAL1を作成する\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Funix.stackexchange.com\u002Fquestions\u002F378373\u002Fadd-virtual-output-to-xorg\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EAdd VIRTUAL output to Xorg - Stack Exchange\u003C\u002Fa\u003E\nを見てみると、 intel ドライバを使って VirtualHeads を作成することができるようです。\u003C\u002Fp\u003E\n\u003Cpre class=\"language-shell\"\u003E\u003Ccode class=\"language-shell\"\u003E\u003Cspan class=\"token function\"\u003Esudo\u003C\u002Fspan\u003E pacman -S xf86-video-intel\n\u003Cspan class=\"token function\"\u003Ecat\u003C\u002Fspan\u003E \u003Cspan class=\"token operator\"\u003E&lt;&lt;\u003C\u002Fspan\u003EEOH \u003Cspan class=\"token operator\"\u003E|\u003C\u002Fspan\u003E \u003Cspan class=\"token function\"\u003Esudo\u003C\u002Fspan\u003E \u003Cspan class=\"token function\"\u003Etee\u003C\u002Fspan\u003E \u002Fetc\u002FX11\u002Fxorg.conf.d\u002F20-intel-virtual-heads.conf\nSection \u003Cspan class=\"token string\"\u003E\"Device\"\u003C\u002Fspan\u003E\n    Identifier \u003Cspan class=\"token string\"\u003E\"intelgpu0\"\u003C\u002Fspan\u003E\n    Driver \u003Cspan class=\"token string\"\u003E\"intel\"\u003C\u002Fspan\u003E\n    Option \u003Cspan class=\"token string\"\u003E\"VirtualHeads\"\u003C\u002Fspan\u003E \u003Cspan class=\"token string\"\u003E\"2\"\u003C\u002Fspan\u003E\nEndSection\nEOH\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EXorg を再起動すると、output として VIRTUAL1 が追加されています。\u003C\u002Fp\u003E\n\u003Cp\u003Eただ、\n\u003Ca href=\"https:\u002F\u002Fwiki.archlinux.jp\u002Findex.php\u002FIntel_Graphics#.E3.82.A4.E3.83.B3.E3.82.B9.E3.83.88.E3.83.BC.E3.83.AB\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EIntel Graphics - Arch Wiki\u003C\u002Fa\u003E\nに書かれていますが、 \u003Ccode\u003Exf86-video-intel\u003C\u002Fcode\u003E は非推奨扱いになっていて、標準の \u003Ccode\u003Emodesetting\u003C\u002Fcode\u003E ドライバが推奨されているようです。\u003C\u002Fp\u003E\n\u003Cp\u003Eとはいえ、\n\u003Ca href=\"https:\u002F\u002Fgitlab.freedesktop.org\u002Fxorg\u002Fxserver\u002Fissues\u002F179\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Exorg\u002Fxserver Issue#179\u003C\u002Fa\u003E\nに issue が上がっていますが、 \u003Ccode\u003Emodesetting\u003C\u002Fcode\u003E ドライバに VirtualHeads 機能は追加されていないようです。\u003C\u002Fp\u003E\n\u003Cp\u003Emodesetting ドライバで仮想ディスプレイを作成する方法も調べてみましたが、うまく情報をみつけることができませんでした。\n本当は Xmonad のワークスペースをマシン間で任意に対応させたいのですが……それはかなり難しそうですね。\u003C\u002Fp\u003E\n","date":"26 February 2020","timeToRead":1}},"context":{}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/gridsome-blog/assets/js/app.122eb624.js" defer></script><script src="/gridsome-blog/assets/js/page--src--templates--post-vue.c275e0ae.js" defer></script>
  </body>
</html>
